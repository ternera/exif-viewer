var EXIF = {
    getData: function(img, callback) {
        console.log('[EXIF Viewer] Fetching data for:', img.src);
        if (!img.src.startsWith('data:') && !img.src.startsWith('blob:')) {
            img.crossOrigin = "Anonymous";
        }
        fetch(img.src, { mode: 'cors' })
            .then(response => response.arrayBuffer())
            .then(buffer => {
                console.log('[EXIF Viewer] Successfully fetched image data');
                img.exifdata = this.readExifData(new Uint8Array(buffer));
                callback.call(img);
            })
            .catch(error => {
                console.error('[EXIF Viewer] Error fetching image:', error);
                img.exifdata = {};
                callback.call(img);
            });
    },
    getAllTags: function(img) {
        return img.exifdata || {};
    },
    readExifData: function(data) {
        if (data.length < 2 || data[0] !== 0xFF || data[1] !== 0xD8) {
            console.log('[EXIF Viewer] Not a valid JPEG');
            return {};
        }
        let offset = 2;
        while (offset < data.length) {
            if (data[offset] !== 0xFF) {
                console.log('[EXIF Viewer] Invalid marker');
                return {};
            }
            let marker = data[offset + 1];
            if (marker === 0xE1) {
                return this.readExifSegment(data, offset + 4);
            }
            offset += 2 + (data[offset + 2] << 8 | data[offset + 3]);
        }
        return {};
    },
    readExifSegment: function(data, start) {
        try {
            const exifData = {};
            const header = Array.from(data.slice(start, start + 6))
                .map(byte => String.fromCharCode(byte))
                .join('');
            if (!header.startsWith('Exif\0\0')) {
                console.log('[EXIF Viewer] Invalid EXIF header:', header);
                return {};
            }
            const tiffStart = start + 6;
            const byteOrder = data[tiffStart];
            const littleEndian = byteOrder === 0x49;
            if (byteOrder !== 0x49 && byteOrder !== 0x4D) {
                console.log('[EXIF Viewer] Invalid byte order marker:', byteOrder);
                return {};
            }
            console.log('[EXIF Viewer] Byte order:', littleEndian ? 'II (little)' : 'MM (big)');
            const tiffCheck = this.getUint16(data, tiffStart + 2, littleEndian);
            if (tiffCheck !== 0x002A) {
                console.log('[EXIF Viewer] Invalid TIFF header:', tiffCheck);
                return {};
            }
            const ifdOffset = this.getUint32(data, tiffStart + 4, littleEndian);
            console.log('[EXIF Viewer] IFD offset:', ifdOffset);
            if (ifdOffset < 8 || ifdOffset > data.length - tiffStart) {
                console.log('[EXIF Viewer] Invalid IFD offset');
                return {};
            }
            const tags = this.readIFD(data, tiffStart + ifdOffset, tiffStart, littleEndian);
            
            this.processGPSData(exifData, tags, data, tiffStart, littleEndian);
            
            const tagMap = {
                0x010F: 'Make',
                0x0110: 'Model',
                0x927C: 'MakerNote',
                0x010E: 'ImageDescription',
                0x0132: 'DateTime',
                0x013B: 'Artist',
                0x8298: 'Copyright',
                0x0128: 'ResolutionUnit',
                0x011A: 'XResolution',
                0x011B: 'YResolution',
                0x0100: 'ImageWidth',
                0x0101: 'ImageHeight',
                0x0106: 'PhotometricInterpretation',
                0x829A: 'ExposureTime',
                0x829D: 'FNumber',
                0x8827: 'ISO',
                0x9204: 'ExposureBiasValue',
                0x9207: 'MeteringMode',
                0x9209: 'Flash',
                0x920A: 'FocalLength',
                0xA402: 'ExposureMode',
                0xA403: 'WhiteBalance',
                0xA406: 'SceneCaptureType',
                0xA432: 'LensSpecification',
                0xA433: 'LensMake',
                0xA434: 'LensModel',
                0x9205: 'MaxApertureValue',
                0x0002: 'GPSLatitude',
                0x001F: 'GPSDateStamp',
                0x0020: 'GPSTimeStamp',
                0x0004: 'GPSLongitude',
            };
            const resolutionUnits = {
                1: 'None',
                2: 'inches',
                3: 'cm'
            };
            const meteringModes = {
                0: 'Unknown',
                1: 'Average',
                2: 'Center-weighted average',
                3: 'Spot',
                4: 'Multi-spot',
                5: 'Multi-segment',
                6: 'Partial',
                255: 'Other'
            };
            const exposureModes = {
                0: 'Auto',
                1: 'Manual',
                2: 'Auto bracket'
            };
            const whiteBalance = {
                0: 'Auto',
                1: 'Manual'
            };
            const sceneCaptureTypes = {
                0: 'Standard',
                1: 'Landscape',
                2: 'Portrait',
                3: 'Night',
                4: 'Other'
            };
            Object.entries(tags).forEach(([tagId, value]) => {
                const numId = parseInt(tagId);
                const key = tagMap[numId];
                if (key) {
                    if (Array.isArray(value)) {
                        if (key === 'XResolution' || key === 'YResolution') {
                            exifData[key] = `${(value[0] / value[1]).toFixed(2)} ${resolutionUnits[tags[0x0128]] || 'units'}`;
                        } else if (key === 'FNumber') {
                            exifData[key] = `f/${(value[0] / value[1]).toFixed(1)}`;
                        } else if (key === 'ExposureBiasValue') {
                            exifData[key] = `${(value[0] / value[1]).toFixed(1)} EV`;
                        } else if (key === 'FocalLength') {
                            exifData[key] = `${(value[0] / value[1]).toFixed(1)}mm`;
                        } 
                        else {
                            exifData[key] = `${value[0]}/${value[1]}`;
                        }
                    } else {
                        if (key === 'MeteringMode') {
                            exifData[key] = meteringModes[value] || `Unknown (${value})`;
                        } else if (key === 'ExposureMode') {
                            exifData[key] = exposureModes[value] || `Unknown (${value})`;
                        } else if (key === 'WhiteBalance') {
                            exifData[key] = whiteBalance[value] || `Unknown (${value})`;
                        } else if (key === 'SceneCaptureType') {
                            exifData[key] = sceneCaptureTypes[value] || `Unknown (${value})`;
                        } else if (typeof value === 'string') {
                            exifData[key] = value.trim();
                        } else {
                            exifData[key] = value.toString();
                        }
                    }
                }
            });
            exifData._raw = tags;
            console.log('[EXIF Viewer] Parsed tags:', tags);
            console.log('[EXIF Viewer] Formatted EXIF data:', exifData);
            return exifData;
        } catch (error) {
            console.error('[EXIF Viewer] Error in readExifSegment:', error);
            return {};
        }
    },
    
    convertDMSToDD: function(degrees, minutes, seconds, direction) {
        let dd = degrees + (minutes / 60) + (seconds / 3600);
        if (direction === 'S' || direction === 'W') {
            dd *= -1;
        }
        return dd;
    },
    
    processGPSData: function(exifData, tags, data, tiffStart, littleEndian) {
        if (!tags[0x8825]) {
            console.log('[EXIF Viewer] No GPS IFD found');
            return;
        }
        
        console.log('[EXIF Viewer] Processing GPS IFD');
        
        const gpsIFD = this.readIFD(data, tiffStart + tags[0x8825], tiffStart, littleEndian);
        console.log('[EXIF Viewer] GPS IFD:', gpsIFD);
        
        let latitude, longitude, latRef, lonRef;
        
        if (gpsIFD[0x0002] && gpsIFD[0x0001]) {
            const latValues = gpsIFD[0x0002];
            latRef = gpsIFD[0x0001];
            
            console.log('[EXIF Viewer] GPS Latitude values:', latValues);
            console.log('[EXIF Viewer] GPS Latitude ref:', latRef);
            
            if (Array.isArray(latValues) && latValues.length === 3) {
                const degrees = latValues[0][0] / latValues[0][1];
                const minutes = latValues[1][0] / latValues[1][1];
                const seconds = latValues[2][0] / latValues[2][1];
                
                latitude = this.convertDMSToDD(degrees, minutes, seconds, latRef);
                console.log('[EXIF Viewer] Calculated GPS Latitude:', latitude.toFixed(6) + '° ' + latRef);
            }
        }
        
        if (gpsIFD[0x0004] && gpsIFD[0x0003]) {
            const lonValues = gpsIFD[0x0004];
            lonRef = gpsIFD[0x0003];
            
            console.log('[EXIF Viewer] GPS Longitude values:', lonValues);
            console.log('[EXIF Viewer] GPS Longitude ref:', lonRef);
            
            if (Array.isArray(lonValues) && lonValues.length === 3) {
                const degrees = lonValues[0][0] / lonValues[0][1];
                const minutes = lonValues[1][0] / lonValues[1][1];
                const seconds = lonValues[2][0] / lonValues[2][1];
                
                longitude = this.convertDMSToDD(degrees, minutes, seconds, lonRef);
                console.log('[EXIF Viewer] Calculated GPS Longitude:', longitude.toFixed(6) + '° ' + lonRef);
            }
        }
        
        if (latitude !== undefined && longitude !== undefined) {
            exifData.GPSLocation = `${latitude.toFixed(6)}, ${longitude.toFixed(6)}`;
            console.log('[EXIF Viewer] Combined GPS Location:', exifData.GPSLocation);
            
            delete exifData.GPSInfo;
        }
        
        if (gpsIFD[0x0007]) {
            const timeValues = gpsIFD[0x0007];
            if (Array.isArray(timeValues) && timeValues.length === 3) {
                const hour = timeValues[0][0] / timeValues[0][1];
                const minute = timeValues[1][0] / timeValues[1][1];
                const second = timeValues[2][0] / timeValues[2][1];
                
                console.log('[EXIF Viewer] GPS TimeStamp:', 
                    `${Math.floor(hour)}:${Math.floor(minute)}:${second.toFixed(1)}`);
            }
        }
    },
    
    readIFD: function(data, offset, tiffStart, littleEndian) {
        const tags = {};
        try {
            const entries = this.getUint16(data, offset, littleEndian);
            console.log(`[EXIF Viewer] Reading IFD with ${entries} entries at offset ${offset - tiffStart}`);
            offset += 2;
            for (let i = 0; i < entries; i++) {
                const tagId = this.getUint16(data, offset, littleEndian);
                const type = this.getUint16(data, offset + 2, littleEndian);
                const count = this.getUint32(data, offset + 4, littleEndian);
                let valueOffset = offset + 8;
                if (type === 2 || type === 5 || count > 1) {
                    valueOffset = tiffStart + this.getUint32(data, offset + 8, littleEndian);
                }
                let value;
                
                const isGPSTag = (offset > tiffStart + 0x8825) && tagId < 0x100;
                
                switch (type) {
                    case 1: 
                        if (count === 1) {
                            value = data[valueOffset];
                        } else {
                            value = Array.from(data.slice(valueOffset, valueOffset + count));
                        }
                        break;
                    case 2: 
                        value = new TextDecoder().decode(data.slice(valueOffset, valueOffset + count - 1));
                        break;
                    case 3: 
                        if (count === 1) {
                            value = this.getUint16(data, valueOffset, littleEndian);
                        } else {
                            value = [];
                            for (let k = 0; k < count; k++) {
                                value.push(this.getUint16(data, valueOffset + k * 2, littleEndian));
                            }
                        }
                        break;
                    case 4: 
                        if (count === 1) {
                            value = this.getUint32(data, valueOffset, littleEndian);
                        } else {
                            value = [];
                            for (let k = 0; k < count; k++) {
                                value.push(this.getUint32(data, valueOffset + k * 4, littleEndian));
                            }
                        }
                        break;
                    case 5: 
                        if (count === 1) {
                            value = [
                                this.getUint32(data, valueOffset, littleEndian),
                                this.getUint32(data, valueOffset + 4, littleEndian)
                            ];
                        } else {
                            value = [];
                            for (let k = 0; k < count; k++) {
                                value.push([
                                    this.getUint32(data, valueOffset + k * 8, littleEndian),
                                    this.getUint32(data, valueOffset + k * 8 + 4, littleEndian)
                                ]);
                            }
                        }
                        break;
                }
                
                if (value !== undefined) {
                    tags[tagId] = value;
                    if (isGPSTag) {
                        const gpsTagNames = {
                            1: 'GPSLatitudeRef', 2: 'GPSLatitude', 3: 'GPSLongitudeRef', 4: 'GPSLongitude', 
                            5: 'GPSAltitudeRef', 6: 'GPSAltitude', 7: 'GPSTimeStamp'
                        };
                        const tagName = gpsTagNames[tagId] || `GPS Tag ${tagId}`;
                        console.log(`[EXIF Viewer] ${tagName} (${tagId.toString(16)}): ${JSON.stringify(value)}`);
                    } else {
                        console.log(`[EXIF Viewer] Tag ${tagId.toString(16)}: ${value}`);
                    }
                }
                offset += 12;
            }
        } catch (error) {
            console.error('[EXIF Viewer] Error reading IFD:', error);
        }
        return tags;
    },
    getUint16: function(data, offset, littleEndian) {
        return littleEndian ?
            (data[offset] | data[offset + 1] << 8) :
            (data[offset] << 8 | data[offset + 1]);
    },
    getUint32: function(data, offset, littleEndian) {
        return littleEndian ?
            (data[offset] | data[offset + 1] << 8 | data[offset + 2] << 16 | data[offset + 3] << 24) :
            (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]);
    },
    getString: function(data) {
        if (typeof data === 'string') return data;
        try {
            return data.trim();
        } catch (error) {
            console.error('[EXIF Viewer] Error converting string:', error);
            return '';
        }
    }
};
