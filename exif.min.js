var EXIF = {
    getData: function(img, callback) {
        console.log('[EXIF Viewer] Fetching data for:', img.src);
        if (!img.src.startsWith('data:') && !img.src.startsWith('blob:')) {
            img.crossOrigin = "Anonymous";
        }
        fetch(img.src, { mode: 'cors' })
            .then(response => response.arrayBuffer())
            .then(buffer => {
                console.log('[EXIF Viewer] Successfully fetched image data');
                img.exifdata = this.readExifData(new Uint8Array(buffer));
                callback.call(img);
            })
            .catch(error => {
                console.error('[EXIF Viewer] Error fetching image:', error);
                img.exifdata = {};
                callback.call(img);
            });
    },
    getAllTags: function(img) {
        return img.exifdata || {};
    },
    readExifData: function(data) {
        if (data.length < 2 || data[0] !== 0xFF || data[1] !== 0xD8) {
            console.log('[EXIF Viewer] Not a valid JPEG');
            return {};
        }
        let offset = 2;
        while (offset < data.length) {
            if (data[offset] !== 0xFF) {
                console.log('[EXIF Viewer] Invalid marker');
                return {};
            }
            let marker = data[offset + 1];
            if (marker === 0xE1) {
                return this.readExifSegment(data, offset + 4);
            }
            offset += 2 + (data[offset + 2] << 8 | data[offset + 3]);
        }
        return {};
    },
    readExifSegment: function(data, start) {
        try {
            const exifData = {};
            const header = Array.from(data.slice(start, start + 6))
                .map(byte => String.fromCharCode(byte))
                .join('');
            if (!header.startsWith('Exif\0\0')) {
                console.log('[EXIF Viewer] Invalid EXIF header:', header);
                return {};
            }
            const tiffStart = start + 6;
            const byteOrder = data[tiffStart];
            const littleEndian = byteOrder === 0x49;
            if (byteOrder !== 0x49 && byteOrder !== 0x4D) {
                console.log('[EXIF Viewer] Invalid byte order marker:', byteOrder);
                return {};
            }
            console.log('[EXIF Viewer] Byte order:', littleEndian ? 'II (little)' : 'MM (big)');
            const tiffCheck = this.getUint16(data, tiffStart + 2, littleEndian);
            if (tiffCheck !== 0x002A) {
                console.log('[EXIF Viewer] Invalid TIFF header:', tiffCheck);
                return {};
            }
            const ifdOffset = this.getUint32(data, tiffStart + 4, littleEndian);
            console.log('[EXIF Viewer] IFD offset:', ifdOffset);
            if (ifdOffset < 8 || ifdOffset > data.length - tiffStart) {
                console.log('[EXIF Viewer] Invalid IFD offset');
                return {};
            }
            const tags = this.readIFD(data, tiffStart + ifdOffset, tiffStart, littleEndian);
            const tagMap = {
                0x010F: 'Make',
                0x0110: 'Model',
                0x927C: 'MakerNote',
                0x010E: 'ImageDescription',
                0x0132: 'DateTime',
                0x013B: 'Artist',
                0x8298: 'Copyright',
                0x0128: 'ResolutionUnit',
                0x011A: 'XResolution',
                0x011B: 'YResolution',
                0x0100: 'ImageWidth',
                0x0101: 'ImageHeight',
                0x0106: 'PhotometricInterpretation',
                0x829A: 'ExposureTime',
                0x829D: 'FNumber',
                0x8827: 'ISO',
                0x9204: 'ExposureBiasValue',
                0x9207: 'MeteringMode',
                0x9209: 'Flash',
                0x920A: 'FocalLength',
                0xA402: 'ExposureMode',
                0xA403: 'WhiteBalance',
                0xA406: 'SceneCaptureType',
                0xA432: 'LensSpecification',
                0xA433: 'LensMake',
                0xA434: 'LensModel',
                0x9205: 'MaxApertureValue',
                0x0002: 'GPSLatitude',
                0x0004: 'GPSLongitude',
                0x0006: 'GPSAltitude',
                0x001F: 'GPSDateStamp',
                0x0020: 'GPSTimeStamp'
            };
            const resolutionUnits = {
                1: 'None',
                2: 'inches',
                3: 'cm'
            };
            const meteringModes = {
                0: 'Unknown',
                1: 'Average',
                2: 'Center-weighted average',
                3: 'Spot',
                4: 'Multi-spot',
                5: 'Multi-segment',
                6: 'Partial',
                255: 'Other'
            };
            const exposureModes = {
                0: 'Auto',
                1: 'Manual',
                2: 'Auto bracket'
            };
            const whiteBalance = {
                0: 'Auto',
                1: 'Manual'
            };
            const sceneCaptureTypes = {
                0: 'Standard',
                1: 'Landscape',
                2: 'Portrait',
                3: 'Night',
                4: 'Other'
            };
            Object.entries(tags).forEach(([tagId, value]) => {
                const numId = parseInt(tagId);
                const key = tagMap[numId];
                if (key) {
                    if (Array.isArray(value)) {
                        if (key === 'XResolution' || key === 'YResolution') {
                            exifData[key] = `${(value[0] / value[1]).toFixed(2)} ${resolutionUnits[tags[0x0128]] || 'units'}`;
                        } else if (key === 'FNumber') {
                            exifData[key] = `f/${(value[0] / value[1]).toFixed(1)}`;
                        } else if (key === 'ExposureBiasValue') {
                            exifData[key] = `${(value[0] / value[1]).toFixed(1)} EV`;
                        } else if (key === 'FocalLength') {
                            exifData[key] = `${(value[0] / value[1]).toFixed(1)}mm`;
                        } else if (key.startsWith('GPS')) {
                            exifData[key] = `${value[0] / value[1]}Â°`;
                        } else {
                            exifData[key] = `${value[0]}/${value[1]}`;
                        }
                    } else {
                        if (key === 'MeteringMode') {
                            exifData[key] = meteringModes[value] || `Unknown (${value})`;
                        } else if (key === 'ExposureMode') {
                            exifData[key] = exposureModes[value] || `Unknown (${value})`;
                        } else if (key === 'WhiteBalance') {
                            exifData[key] = whiteBalance[value] || `Unknown (${value})`;
                        } else if (key === 'SceneCaptureType') {
                            exifData[key] = sceneCaptureTypes[value] || `Unknown (${value})`;
                        } else if (typeof value === 'string') {
                            exifData[key] = value.trim();
                        } else {
                            exifData[key] = value.toString();
                        }
                    }
                }
            });
            exifData._raw = tags;
            console.log('[EXIF Viewer] Parsed tags:', tags);
            console.log('[EXIF Viewer] Formatted EXIF data:', exifData);
            return exifData;
        } catch (error) {
            console.error('[EXIF Viewer] Error in readExifSegment:', error);
            return {};
        }
    },
    readIFD: function(data, offset, tiffStart, littleEndian) {
        const tags = {};
        try {
            const entries = this.getUint16(data, offset, littleEndian);
            offset += 2;
            for (let i = 0; i < entries; i++) {
                const tagId = this.getUint16(data, offset, littleEndian);
                const type = this.getUint16(data, offset + 2, littleEndian);
                const count = this.getUint32(data, offset + 4, littleEndian);
                let valueOffset = offset + 8;
                if (type === 2 || type === 5 || count > 1) {
                    valueOffset = tiffStart + this.getUint32(data, offset + 8, littleEndian);
                }
                let value;
                switch (type) {
                    case 2:
                        value = new TextDecoder().decode(data.slice(valueOffset, valueOffset + count - 1));
                        break;
                    case 3:
                        value = this.getUint16(data, valueOffset, littleEndian);
                        break;
                    case 4:
                        value = this.getUint32(data, valueOffset, littleEndian);
                        break;
                    case 5:
                        value = [
                            this.getUint32(data, valueOffset, littleEndian),
                            this.getUint32(data, valueOffset + 4, littleEndian)
                        ];
                        break;
                }
                if (value !== undefined) {
                    tags[tagId] = value;
                    console.log(`[EXIF Viewer] Tag ${tagId.toString(16)}: ${value}`);
                }
                offset += 12;
            }
        } catch (error) {
            console.error('[EXIF Viewer] Error reading IFD:', error);
        }
        return tags;
    },
    getUint16: function(data, offset, littleEndian) {
        return littleEndian ?
            (data[offset] | data[offset + 1] << 8) :
            (data[offset] << 8 | data[offset + 1]);
    },
    getUint32: function(data, offset, littleEndian) {
        return littleEndian ?
            (data[offset] | data[offset + 1] << 8 | data[offset + 2] << 16 | data[offset + 3] << 24) :
            (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]);
    },
    getString: function(data) {
        if (typeof data === 'string') return data;
        try {
            return data.trim();
        } catch (error) {
            console.error('[EXIF Viewer] Error converting string:', error);
            return '';
        }
    }
};
